import os
import sys
from os import path
"""Import the basics; numpy, pandas, matplotlib et al."""
import pandas as pd
import numpy as np
import seaborn
import matplotlib.pyplot as plt
from matplotlib.offsetbox import AnchoredText
from matplotlib.ticker import ScalarFormatter, FormatStrFormatter, NullFormatter
"""Import keras and other ML tools"""
import tensorflow as tf
import keras
# print("keras version:", keras.__version__)
# print("tensorflow version:", tf.__version__)
from keras.models import Model, load_model, Sequential
from keras.layers import Input, Dense, Activation, ZeroPadding2D, BatchNormalization, Flatten, Conv2D
from keras.layers.convolutional import Conv3D, Conv3DTranspose
from keras.layers.core import Dropout, Lambda
from keras.callbacks import EarlyStopping, ModelCheckpoint
from tensorflow.keras.utils import to_categorical
from keras.preprocessing.image import ImageDataGenerator, array_to_img, img_to_array, load_img
"""Import scikit learn tools"""
from sklearn.model_selection import train_test_split, cross_val_score, KFold
from sklearn.metrics import confusion_matrix, accuracy_score
from sklearn.preprocessing import OneHotEncoder
from sklearn.utils.multiclass import unique_labels
from sklearn.model_selection import StratifiedKFold, StratifiedShuffleSplit


"""
This module contains the baseline convolutional neural network (CNN) model and the functions that call it to fit.
This predictive capability of this baseline neural network (NN) is used to compare against those of more complex 
NN architectures, such as DenseNet by Huang et al. (2016).
"""


def conv_twod_model(input_shape, num_classes, dropout_rate=0.10):

    model = Sequential()

    model.add(Conv2D(filters=16, kernel_size=(3, 3), input_shape=input_shape, data_format="channels_last", activation='relu', padding='same'))
    model.add(Dropout(dropout_rate))

    model.add(Conv2D(filters=32, kernel_size=(3, 3), data_format="channels_last", activation='relu', padding='same'))
    model.add(Dropout(dropout_rate))

    model.add(Conv2D(filters=64, kernel_size=(3, 3), data_format="channels_last", activation='relu', padding='same'))
    model.add(Dropout(dropout_rate*2))

    model.add(Conv2D(filters=256, kernel_size=(3, 3), data_format="channels_last", activation='relu', padding='same'))
    model.add(Dropout(dropout_rate*3))
    """Flatten & map to fully-connected layers"""
    model.add(Flatten())
    model.add(Dense(512, activation='relu'))
    model.add(Dropout(dropout_rate*2))
    model.add(Dense(128, activation='relu'))
    model.add(Dropout(dropout_rate))
    model.add(Dense(num_classes, activation='softmax'))

    return model


def fit_baseline_convnet(train_imgs, train_labels, test_imgs, test_labels, num_class, class_names):

    """This function builds and trains the baseline convolutional neural network."""

    convnet_model = conv_twod_model(train_imgs.shape[1:], num_class, dropout_rate=0.10)
    convnet_model.summary()

    sgd_optimizer = keras.optimizers.SGD(lr=0.005, momentum=0.0, nesterov=False)
    # adam_optimizer = keras.optimizers.adam(lr=0.0001)
    convnet_model.compile(optimizer=sgd_optimizer, loss='categorical_crossentropy', metrics=["accuracy"])
    """Set the specifications of the data augmentation to be performed below"""
    datagen = ImageDataGenerator(featurewise_center=False,  # set input mean to 0 over the dataset
                                 samplewise_center=False,  # set each sample mean to 0
                                 featurewise_std_normalization=False,  # divide inputs by std of the dataset
                                 samplewise_std_normalization=False,  # divide each input by its std
                                 zca_whitening=False,  # apply ZCA whitening
                                 rotation_range=0.0,  # randomly rotate images in the range (degrees, 0 to 180)
                                 width_shift_range=0.0,  # randomly shift images horizontally (fraction of total width)
                                 height_shift_range=0.0,  # randomly shift images vertically (fraction of total height)
                                 horizontal_flip=True,  # randomly flip images on the horizontal axis
                                 vertical_flip=True)  # randomly flip images on the vertical axis

    datagen.fit(train_imgs)

    """Fit the model on the batches generated by datagen.flow()"""
    batch_size = 32
    epochs = 200
    classifier = convnet_model.fit_generator(datagen.flow(train_imgs, train_labels, batch_size=batch_size),
                                             steps_per_epoch=train_imgs.shape[0] // batch_size,
                                             validation_data=(test_imgs, test_labels),
                                             epochs=epochs, verbose=1, max_q_size=100, shuffle=True)

    """Plot accuracy/loss versus epoch"""

    fig = plt.figure(figsize=(10, 3))

    ax1 = plt.subplot(121)
    ax1.plot(classifier.history['accuracy'], color='darkslategray', linewidth=2, label='Accuracy')
    ax1.plot(classifier.history['val_accuracy'], color='forestgreen', linewidth=2, label='Validation Accuracy')
    ax1.set_title('Model Accuracy')
    ax1.set_ylabel('Accuracy')
    ax1.set_xlabel('Epoch')
    ax1.xaxis.set_label_coords(0.5, -0.15)
    ax1.legend(loc='lower right')

    ax2 = plt.subplot(122)
    ax2.plot(classifier.history['loss'], color='crimson', linewidth=2, label='Loss')
    ax2.plot(classifier.history['val_loss'], color='silver', linewidth=2, label='Validation Loss')
    ax2.set_title('Model Loss')
    ax2.set_ylabel('Loss')
    ax2.set_xlabel('Epoch')
    ax2.xaxis.set_label_coords(0.5, -0.15)
    ax2.set_ylim(0, 2)
    ax2.legend(loc='upper right')

    plt.savefig('baseline_convnet_accuracy-loss_{:04d}_epochs.pdf'.format(epochs), type='pdf')
    plt.close()

    preds_test = convnet_model.predict(test_imgs)
    preds_test_t = np.argmax(preds_test, axis=1)

    test_labels_t = np.argmax(test_labels, axis=1)

    print('Fraction of correct predictions with the baseline convolutional neural network:',
          round(accuracy_score(test_labels_t, preds_test_t), 2))
    """Plot the confusion matrix below"""
    conf_classes = np.array(class_names)
    print(conf_classes.dtype)
    plot_confusion_matrix(test_labels_t, preds_test_t, normalize=True, classes=conf_classes,
                          title='Normalized Confusion Matrix -- Baseline Convnet')
    plt.savefig(str(len(conf_classes)) + '_class-pred_confmatrix_baseline_convnet_{:04d}_epochs.pdf'.format(epochs), type='pdf')
    plt.close()

